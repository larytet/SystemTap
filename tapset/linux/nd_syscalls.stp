
# mkdirat ____________________________________________________
# new function with 2.6.16
# long sys_mkdirat(int dfd, const char __user *pathname, int mode)
probe nd_syscall.mkdirat = kprobe.function("sys_mkdirat") ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	asmlinkage()
	dirfd = int_arg(1)
	dirfd_str = _dfd_str(dirfd)
	pathname = user_string_quoted(pointer_arg(2))
	mode = uint_arg(3)
	argstr = sprintf("%s, %s, %#o", dirfd_str,
			 user_string_quoted(pointer_arg(2)), mode)
}
probe nd_syscall.mkdirat.return = kprobe.function("sys_mkdirat").return ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	retstr = returnstr(1)
}

# mknod ______________________________________________________
# long sys_mknod(const char __user * filename, int mode, unsigned dev)
probe nd_syscall.mknod = kprobe.function("sys_mknod") ?
{
	name = "mknod"
	asmlinkage()
	pathname = user_string_quoted(pointer_arg(1))
	mode = uint_arg(2)
	dev = uint_arg(3)
	argstr = sprintf("%s, %s, %u", pathname, _mknod_mode_str(mode), dev)
}

probe nd_syscall.mknod.return = kprobe.function("sys_mknod").return ?
{
	name = "mknod"
	retstr = returnstr(1)
}

# mknodat ____________________________________________________
# new function with 2.6.16
# long sys_mknodat(int dfd, const char __user *filename,
#	int mode, unsigned dev)
probe nd_syscall.mknodat = kprobe.function("sys_mknodat") ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	asmlinkage()
	dirfd = int_arg(1)
	dirfd_str = _dfd_str(dirfd)
	pathname = user_string_quoted(pointer_arg(2))
	mode = uint_arg(3)
	mode_str = _mknod_mode_str(mode)
	dev = uint_arg(4)
	argstr = sprintf("%s, %s, %s, %u",
		dirfd_str, pathname, mode_str, dev)
}
probe nd_syscall.mknodat.return = kprobe.function("sys_mknodat").return ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	retstr = returnstr(1)
}

# mlock ______________________________________________________
#
# long sys_mlock(unsigned long start, size_t len)
#
probe nd_syscall.mlock = kprobe.function("sys_mlock") ?
{
	name = "mlock"
	asmlinkage()
	addr = ulong_arg(1)
	len = ulong_arg(2)
	argstr = sprintf("%p, %u", addr, len)
}
probe nd_syscall.mlock.return = kprobe.function("sys_mlock").return ?
{
	name = "mlock"
	retstr = returnstr(1)
}

# mlock2 _____________________________________________________
#
# long sys_mlock2(unsigned long start, size_t len, int flags)
#
probe nd_syscall.mlock2 = kprobe.function("sys_mlock2") ?
{
	name = "mlock2"
	asmlinkage()
	addr = ulong_arg(1)
	len = ulong_arg(2)
	flags = int_arg(3)
	flags_str = _stp_mlock2_str(flags)
	argstr = sprintf("%p, %u, %s", addr, len, flags_str)
}
probe nd_syscall.mlock2.return = kprobe.function("sys_mlock2").return ?
{
	name = "mlock2"
	retstr = returnstr(1)
}

# mlockall ___________________________________________________
#
# long sys_mlockall(int flags)
#
probe nd_syscall.mlockall = kprobe.function("sys_mlockall") ?
{
	name = "mlockall"
	asmlinkage()
	flags = int_arg(1)
	argstr = _mlockall_flags_str(flags)
}
probe nd_syscall.mlockall.return = kprobe.function("sys_mlockall").return ?
{
	name = "mlockall"
	retstr = returnstr(1)
}

# modify_ldt _________________________________________________
# int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
#
probe nd_syscall.modify_ldt = kprobe.function("sys_modify_ldt") ?
{
	name = "modify_ldt"
	asmlinkage()
	func = int_arg(1)
	ptr_uaddr = pointer_arg(2)
	bytecount = ulong_arg(3)
	argstr = sprintf("%d, %p, %u", func, ptr_uaddr, bytecount)
}
probe nd_syscall.modify_ldt.return = kprobe.function("sys_modify_ldt").return ?
{
	name = "modify_ldt"
	retstr = returnstr(1)
}

# move_pages ____________________________________________________
# long sys_move_pages(pid_t pid, unsigned long nr_pages,
#			const void __user * __user *pages,
#			const int __user *nodes,
#			int __user *status,
#			int flags)
#
# long compat_sys_move_pages(pid_t pid, unsigned long nr_pages,
#                compat_uptr_t __user *pages32,
#                const int __user *nodes,
#                int __user *status,
#                int flags)
#
probe nd_syscall.move_pages = __nd_syscall.move_pages ?,
                              kprobe.function("compat_sys_move_pages") ?
{
	name = "move_pages"
	asmlinkage()
	pid = int_arg(1)
	nr_pages = ulong_arg(2)
	pages = pointer_arg(3)
	nodes = pointer_arg(4)
	status = pointer_arg(5)
	flags = int_arg(6)
	flags_str = _mempolicy_flags_str(flags)
	argstr = sprintf("%d, %u, %p, %p, %p, %s", pid, nr_pages, pages,
                         nodes, status, flags_str)
}
probe __nd_syscall.move_pages = kprobe.function("sys_move_pages")
{
	@__syscall_gate(@const("__NR_move_pages"))
}
probe nd_syscall.move_pages.return = __nd_syscall.move_pages.return ?,
                                     kprobe.function("compat_sys_move_pages").return ?
{
	name = "move_pages"
	retstr = returnstr(1)
}
probe __nd_syscall.move_pages.return = kprobe.function("sys_move_pages").return
{
	@__syscall_gate(@const("__NR_move_pages"))
}

# mount ______________________________________________________
# long sys_mount(char __user * dev_name,
# 		char __user * dir_name,
# 		char __user * type,
# 		unsigned long flags,
# 		void __user * data)
# long compat_sys_mount(char __user * dev_name,
#		char __user * dir_name,
#		char __user * type,
#		unsigned long flags,
#		void __user * data)
probe nd_syscall.mount = kprobe.function("compat_sys_mount") ?,
                         kprobe.function("sys_mount") ?
{
	name = "mount"
	asmlinkage()
	source = user_string_quoted(pointer_arg(1))
	target = user_string_quoted(pointer_arg(2))
	filesystemtype = user_string_quoted(pointer_arg(3))
	mountflags = ulong_arg(4)
	mountflags_str = _mountflags_str(mountflags)
	data = user_string_n_quoted(pointer_arg(5), syscall_string_trunc)
	argstr = sprintf("%s, %s, %s, %s, %s",
		user_string_quoted(pointer_arg(1)),
		user_string_quoted(pointer_arg(2)),
		user_string_quoted(pointer_arg(3)),
		mountflags_str, data)
}
probe nd_syscall.mount.return = kprobe.function("compat_sys_mount").return ?,
                                kprobe.function("sys_mount").return ?
{
	name = "mount"
	retstr = returnstr(1)
}

%( kernel_v >= "2.6.33" %?
# In newer kernels (2.6.33+), all the sys_mmap() variants are just
# wrappers around sys_mmap_pgoff(), which is in arch-generic code.
#
# long sys_mmap_pgoff(unsigned long addr, unsigned long len,
#		unsigned long prot, unsigned long flags,
#		unsigned long fd, unsigned long pgoff)
probe nd_syscall.mmap2 = kprobe.function("sys_mmap_pgoff") ?
{
	name = "mmap2"
	asmlinkage()
	start = ulong_arg(1)
	length = ulong_arg(2)
	prot = ulong_arg(3)
	flags = ulong_arg(4)
	# Although the kernel gets an unsigned long fd, on the
	# user-side it is a signed int.  Fix this.
	fd = int_arg(5)
	# $pgoff is the number of pages. Convert this back into a
	# number of bytes.
	pgoffset = ulong_arg(6) * @const("PAGE_SIZE")
	argstr = sprintf("%p, %u, %s, %s, %d, %d", start, length,
		_mprotect_prot_str(prot), _mmap_flags(flags),
		fd, pgoffset)
}
probe nd_syscall.mmap2.return = kprobe.function("sys_mmap_pgoff").return ?
{
        name = "mmap2"
        retstr = returnstr(2)
}
%)

# mprotect ___________________________________________________
# long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
#
probe nd_syscall.mprotect = kprobe.function("sys_mprotect") ?
{
	name = "mprotect"
	asmlinkage()
	addr = ulong_arg(1)
	len = ulong_arg(2)
	prot = ulong_arg(3)
	prot_str = _mprotect_prot_str(prot)
	argstr = sprintf("%p, %d, %s", addr, len, _mprotect_prot_str(prot))
}
probe nd_syscall.mprotect.return = kprobe.function("sys_mprotect").return ?
{
	name = "mprotect"
	retstr = returnstr(1)
}

# mq_getsetattr ______________________________________________
# long sys_mq_getsetattr(mqd_t mqdes,
#                  const struct mq_attr __user *u_mqstat,
#                  struct mq_attr __user *u_omqstat)
# long compat_sys_mq_getsetattr(mqd_t mqdes,
#			const struct compat_mq_attr __user *u_mqstat,
#			struct compat_mq_attr __user *u_omqstat)
#
probe nd_syscall.mq_getsetattr =
        __nd_syscall.mq_getsetattr ?,
        kprobe.function("compat_sys_mq_getsetattr") ?
{
	name = "mq_getsetattr"
	asmlinkage()
	mqdes = int_arg(1)
	u_mqstat_uaddr = pointer_arg(2)
	u_omqstat_uaddr = pointer_arg(3)
	argstr = sprintf("%d, %p, %p", mqdes, u_mqstat_uaddr, u_omqstat_uaddr)
}
probe __nd_syscall.mq_getsetattr = kprobe.function("sys_mq_getsetattr")
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}
probe nd_syscall.mq_getsetattr.return =
        __nd_syscall.mq_getsetattr.return ?,
        kprobe.function("compat_sys_mq_getsetattr").return ?
{
	name = "mq_getsetattr"
	retstr = returnstr(1)
}
probe __nd_syscall.mq_getsetattr.return = kprobe.function("sys_mq_getsetattr").return
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}

# mq_notify __________________________________________________
# long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
# long compat_sys_mq_notify(mqd_t mqdes, const struct compat_sigevent __user *u_notification)
#
probe nd_syscall.mq_notify =
        __nd_syscall.mq_notify ?,
        kprobe.function("compat_sys_mq_notify") ?
{
	name = "mq_notify"
	asmlinkage()
	mqdes = int_arg(1)
	notification_uaddr = pointer_arg(2)
	argstr = sprintf("%d, %p", mqdes, notification_uaddr)
}
probe __nd_syscall.mq_notify = kprobe.function("sys_mq_notify")
{
        @__syscall_gate(@const("__NR_mq_notify"))
}
probe nd_syscall.mq_notify.return =
        __nd_syscall.mq_notify.return ?,
        kprobe.function("compat_sys_mq_notify").return ?
{
	name = "mq_notify"
	retstr = returnstr(1)
}
probe __nd_syscall.mq_notify.return = kprobe.function("sys_mq_notify").return
{
        @__syscall_gate(@const("__NR_mq_notify"))
}

# mq_open ____________________________________________________
# long  sys_mq_open(const char __user *u_name,
#             int oflag,
#             mode_t mode,
#             struct mq_attr __user *u_attr)
# long compat_sys_mq_open(const char __user *u_name,
#			int oflag, compat_mode_t mode,
#			struct compat_mq_attr __user *u_attr)
#
probe nd_syscall.mq_open = __nd_syscall.mq_open,
                           __nd_syscall.compat_mq_open ?
{
	asmlinkage()
	name = "mq_open"
	name_uaddr = pointer_arg(1)
	filename = user_string_quoted(name_uaddr)
	u_attr_uaddr = pointer_arg(4)
	oflag = int_arg(2)
	if (oflag & 64)
		argstr = sprintf("%s, %s, %#o, %p",
			user_string_quoted(name_uaddr),
			_sys_open_flag_str(oflag), mode, u_attr_uaddr)
	else
		argstr = sprintf("%s, %s", user_string_quoted(name_uaddr), _sys_open_flag_str(oflag))
}
probe __nd_syscall.mq_open = kprobe.function("sys_mq_open")
{
	asmlinkage()
        @__syscall_gate(@const("__NR_mq_open"))
%( CONFIG_64BIT == "y" %?
        mode = uint_arg(3)
%:
        mode = (uint_arg(3) & 0xffff)
%)
}
probe __nd_syscall.compat_mq_open = kprobe.function("compat_sys_mq_open")
{
	asmlinkage()
	mode = (uint_arg(3) & 0xffff)
}
probe nd_syscall.mq_open.return =
        __nd_syscall.mq_open.return ?,
        kprobe.function("compat_sys_mq_open").return ?
{
	name = "mq_open"
	retstr = returnstr(1)
}
probe __nd_syscall.mq_open.return = kprobe.function("sys_mq_open").return
{
        @__syscall_gate(@const("__NR_mq_open"))
}

# mq_timedreceive ____________________________________________
# ssize_t sys_mq_timedreceive(mqd_t mqdes,
#                     char __user *u_msg_ptr,
#                     size_t msg_len,
#                     unsigned int __user *u_msg_prio,
#                     const struct timespec __user *u_abs_timeout)
# ssize_t compat_sys_mq_timedreceive(mqd_t mqdes,
#			char __user *u_msg_ptr,
#			size_t msg_len, unsigned int __user *u_msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe nd_syscall.mq_timedreceive =
        __nd_syscall.mq_timedreceive ?,
	__nd_syscall.compat_mq_timedreceive ?
{
	name = "mq_timedreceive"
	asmlinkage()
	mqdes = int_arg(1)
	msg_ptr_uaddr = pointer_arg(2)
	msg_prio_uaddr = pointer_arg(4)
	abs_timeout_uaddr = pointer_arg(5)
	argstr = sprintf("%d, %p, %u, %p, %p", mqdes, msg_ptr_uaddr, msg_len,
		msg_prio_uaddr, abs_timeout_uaddr)
}
probe __nd_syscall.compat_mq_timedreceive = kprobe.function("compat_sys_mq_timedreceive")
{
	asmlinkage()
	msg_len = uint_arg(3)
}
probe __nd_syscall.mq_timedreceive = kprobe.function("sys_mq_timedreceive")
{
	asmlinkage()
        @__syscall_gate(@const("__NR_mq_timedreceive"))
%( CONFIG_64BIT == "y" %?
	msg_len = ulong_arg(3)
%:
	msg_len = uint_arg(3)
%)
}
probe nd_syscall.mq_timedreceive.return =
        __nd_syscall.mq_timedreceive.return ?,
        kprobe.function("compat_sys_mq_timedreceive").return ?
{
	name = "mq_timedreceive"
	retstr = returnstr(1)
}
probe __nd_syscall.mq_timedreceive.return = kprobe.function("sys_mq_timedreceive").return
{
        @__syscall_gate(@const("__NR_mq_timedreceive"))
}

# mq_timedsend _______________________________________________
# long sys_mq_timedsend(mqd_t mqdes,
#                  const char __user *u_msg_ptr,
#                  size_t msg_len,
#                  unsigned int msg_prio,
#                  const struct timespec __user *u_abs_timeout)
#  long compat_sys_mq_timedsend(mqd_t mqdes,
#			const char __user *u_msg_ptr,
#			size_t msg_len, unsigned int msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe nd_syscall.mq_timedsend =
        __nd_syscall.mq_timedsend ?,
        __nd_syscall.compat_mq_timedsend ?
{
	name = "mq_timedsend"
	asmlinkage()
	mqdes = int_arg(1)
	msg_ptr_uaddr = pointer_arg(2)
	msg_prio = uint_arg(4)
	abs_timeout_uaddr = pointer_arg(5)
	argstr = sprintf("%d, %p, %u, %u, %p", mqdes, msg_ptr_uaddr, msg_len,
		msg_prio, abs_timeout_uaddr)
}
probe __nd_syscall.compat_mq_timedsend = kprobe.function("compat_sys_mq_timedsend")
{
	asmlinkage()
	msg_len = uint_arg(3)
}
probe __nd_syscall.mq_timedsend = kprobe.function("sys_mq_timedsend")
{
	asmlinkage()
        @__syscall_gate(@const("__NR_mq_timedsend"))
%( CONFIG_64BIT == "y" %?
	msg_len = ulong_arg(3)
%:
	msg_len = uint_arg(3)
%)
}
probe nd_syscall.mq_timedsend.return =
        __nd_syscall.mq_timedsend.return ?,
        kprobe.function("compat_sys_mq_timedsend").return ?
{
	name = "mq_timedsend"
	retstr = returnstr(1)
}
probe __nd_syscall.mq_timedsend.return = kprobe.function("sys_mq_timedsend").return
{
        @__syscall_gate(@const("__NR_mq_timedsend"))
}

# mq_unlink __________________________________________________
# long sys_mq_unlink(const char __user *u_name)
#
probe nd_syscall.mq_unlink = kprobe.function("sys_mq_unlink") ?
{
	name = "mq_unlink"
	asmlinkage()
	u_name_uaddr = pointer_arg(1)
	u_name = user_string_quoted(u_name_uaddr)
	argstr = user_string_quoted(u_name_uaddr)
}
probe nd_syscall.mq_unlink.return = kprobe.function("sys_mq_unlink").return ?
{
	name = "mq_unlink"
	retstr = returnstr(1)
}

# mremap _____________________________________________________
# unsigned long sys_mremap(unsigned long addr,
#            unsigned long old_len,
#            unsigned long new_len,
#            unsigned long flags,
#            unsigned long new_addr)
#
probe nd_syscall.mremap = kprobe.function("ia64_mremap") ?,
                          kprobe.function("sys_mremap") ?
{
	name = "mremap"
	asmlinkage()
	old_address = ulong_arg(1)
	old_size = ulong_arg(2)
	new_size = ulong_arg(3)
	flags = ulong_arg(4)
	new_address = ulong_arg(5)
	argstr = sprintf("%p, %d, %d, %s, %p", old_address, old_size, new_size,
		_mremap_flags(flags), new_address)
}
probe nd_syscall.mremap.return = kprobe.function("ia64_mremap").return ?,
                                 kprobe.function("sys_mremap").return ?
{
	name = "mremap"
	retstr = returnstr(2)
}

# msgctl _____________________________________________________
# long sys_msgctl (int msqid, int cmd, struct msqid_ds __user *buf)
#
probe nd_syscall.msgctl = kprobe.function("sys_msgctl") ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	asmlinkage()
	msqid = int_arg(1)
	cmd = int_arg(2)
	cmd_str = _stp_msgctl_cmd_str(cmd)
	buf_uaddr = pointer_arg(3)
	argstr = sprintf("%d, %s, %p", msqid, cmd_str, buf_uaddr)
}
probe nd_syscall.msgctl.return = kprobe.function("sys_msgctl").return ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	retstr = returnstr(1)
}
# compat_sys_msgctl ________________________________________
#
# long compat_sys_msgctl(int first, int second, void __user *uptr)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe nd_syscall.compat_sys_msgctl = __nd_syscall.compat_msgctl ?,
      __nd_syscall.compat_ipc.msgctl ?
{
	name = "msgctl"
	asmlinkage()
	cmd_str = _stp_msgctl_cmd_str(cmd)
	argstr = sprintf("%d, %s, %p", msqid, cmd_str, buf_uaddr)
}
probe __nd_syscall.compat_msgctl = kprobe.function("compat_sys_msgctl") ?
{
	asmlinkage()
	msqid = int_arg(1)
	cmd = int_arg(2)
	buf_uaddr = pointer_arg(3)
}
probe __nd_syscall.compat_ipc.msgctl = kprobe.function("compat_sys_ipc") ?
{
	asmlinkage()
	if ((uint_arg(1) & 0xffff) != @const("MSGCTL")) next;
	msqid = int_arg(2)
	cmd = int_arg(3)
	buf_uaddr = pointer_arg(5)
}
probe nd_syscall.compat_sys_msgctl.return =
	kprobe.function("compat_sys_msgctl").return ?,
	__nd_syscall.compat_ipc.msgctl.return ?
{
	name = "msgctl"
	retstr = returnstr(1)
}
probe __nd_syscall.compat_ipc.msgctl.return =
	kprobe.function("compat_sys_ipc").return ?
{
	if ((@entry(__asmlinkage_int_arg(1)) & 0xffff) != @const("MSGCTL")) next;
}

# msgget _____________________________________________________
# long sys_msgget (key_t key, int msgflg)
#
probe nd_syscall.msgget = kprobe.function("sys_msgget") ?
{
	name = "msgget"
	asmlinkage()
	key = int_arg(1)
	key_str = _stp_msgget_key_str(key)
	msgflg = int_arg(2)
	msgflg_str = __sem_flags(msgflg)
	argstr = sprintf("%s, %s", key_str, msgflg_str)
}
probe nd_syscall.msgget.return = kprobe.function("sys_msgget").return ?
{
	name = "msgget"
	retstr = returnstr(1)
}

# msgrcv _____________________________________________________
# long sys_msgrcv (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             long msgtyp,
#             int msgflg)
#
probe nd_syscall.msgrcv = kprobe.function("sys_msgrcv") ?
{
	name = "msgrcv"
	asmlinkage()
	msqid = int_arg(1)
	msgp_uaddr = pointer_arg(2)
	msgsz = ulong_arg(3)
	msgtyp = long_arg(4)
	msgflg = int_arg(5)
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %d, %s", msqid, msgp_uaddr, msgsz,
			 msgtyp, msgflg_str)
}
probe nd_syscall.msgrcv.return = kprobe.function("sys_msgrcv").return ?
{
	name = "msgrcv"
	retstr = returnstr(1)
}
# compat_sys_msgrcv ________________________________________
#
# kernels < 3.15:
# long compat_sys_msgrcv(int first, int second, int msgtyp, int third,
#			int version, void __user *uptr)
#
# kernels >= 3.15:
# COMPAT_SYSCALL_DEFINE5(msgrcv, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, compat_long_t, msgtyp, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe nd_syscall.compat_sys_msgrcv = __nd_syscall.compat_msgrcv ?,
	__nd_syscall.compat_ipc.msgrcv ?
{
	name = "msgrcv"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %d, %s", msqid, msgp_uaddr, msgsz,
			 msgtyp, msgflg_str)
}
probe __nd_syscall.compat_msgrcv = kprobe.function("compat_sys_msgrcv") ?
{
	asmlinkage()
	msqid = int_arg(1)
%(kernel_v >= "3.15.0" %?
	msgp_uaddr = pointer_arg(2)
	msgsz = uint_arg(3)
	msgtyp = long_arg(4)
	msgflg = int_arg(5)
%:
	__version = int_arg(5)
	__uptr = pointer_arg(6)
	msgp_uaddr = _stp_compat_msgrcv_msgbuf(__uptr, __version)
	msgtyp = _stp_compat_msgrcv_msgtyp(__uptr, __version, int_arg(3))
	msgsz = uint_arg(2)
	msgflg = int_arg(4)
%)
}
probe __nd_syscall.compat_ipc.msgrcv = kprobe.function("compat_sys_ipc") ?
{
	asmlinkage()
	if ((uint_arg(1) & 0xffff) != @const("MSGRCV")) next;
	msqid = int_arg(2)
	msgsz = uint_arg(3)
	msgflg = int_arg(4)

	# __version isn't quite correct (it should be shifted down 16
	# bits), but all we really need is zero/non-zero.
	__version = uint_arg(1) & 0xffff0000
	__uptr = pointer_arg(5)
	msgp_uaddr = _stp_compat_msgrcv_msgbuf(__uptr, __version)
	msgtyp = _stp_compat_msgrcv_msgtyp(__uptr, __version, int_arg(6))
}
probe nd_syscall.compat_sys_msgrcv.return =
	kprobe.function("compat_sys_msgrcv").return ?,
	__nd_syscall.compat_ipc.msgrcv.return ?
{
	name = "msgrcv"
	retstr = returnstr(1)
}
probe __nd_syscall.compat_ipc.msgrcv.return =
	kprobe.function("compat_sys_ipc").return ?
{
	if ((@entry(__asmlinkage_int_arg(1)) & 0xffff) != @const("MSGRCV")) next;
}

# msgsnd _____________________________________________________
# long sys_msgsnd (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             int msgflg)
#
probe nd_syscall.msgsnd = kprobe.function("sys_msgsnd") ?
{
	name = "msgsnd"
	asmlinkage()
	msqid = int_arg(1)
	msgp_uaddr = pointer_arg(2)
	msgsz = ulong_arg(3)
	msgflg = int_arg(4)
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz, msgflg_str)
}
probe nd_syscall.msgsnd.return = kprobe.function("sys_msgsnd").return ?
{
	name = "msgsnd"
	retstr = returnstr(1)
}
# compat_sys_msgsnd ________________________________________
#
# long compat_sys_msgsnd(int first, int second, int third, void __user *uptr)
#
probe nd_syscall.compat_sys_msgsnd = __nd_syscall.compat_msgsnd ?,
	__nd_syscall.compat_ipc.msgsnd ?
{
	name = "msgsnd"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz, msgflg_str)
}
probe __nd_syscall.compat_msgsnd = kprobe.function("compat_sys_msgsnd") ?
{
	asmlinkage()
	msqid = int_arg(1)
	msgsz = uint_arg(2)
	msgflg = int_arg(3)
	msgp_uaddr = pointer_arg(4)
}
probe __nd_syscall.compat_ipc.msgsnd = kprobe.function("compat_sys_ipc") ?
{
	asmlinkage()
	if ((uint_arg(1) & 0xffff) != @const("MSGSND")) next;
	msqid = int_arg(2)
	msgsz = uint_arg(3)
	msgflg = int_arg(4)
	msgp_uaddr = pointer_arg(5)
}
probe nd_syscall.compat_sys_msgsnd.return =
	kprobe.function("compat_sys_msgsnd").return ?,
	__nd_syscall.compat_ipc.msgsnd.return ?
{
	name = "msgsnd"
	retstr = returnstr(1)
}
probe __nd_syscall.compat_ipc.msgsnd.return =
	kprobe.function("compat_sys_ipc").return ?
{
	if ((@entry(__asmlinkage_int_arg(1)) & 0xffff) != @const("MSGSND")) next;
}

# msync ______________________________________________________
# long sys_msync(unsigned long start, size_t len, int flags)
probe nd_syscall.msync = kprobe.function("sys_msync") ?
{
	name = "msync"
	asmlinkage()
	start = ulong_arg(1)
	length = ulong_arg(2)
	flags = int_arg(3)
	argstr = sprintf("%p, %u, %s", start, length, _msync_flag_str(flags))
}
probe nd_syscall.msync.return = kprobe.function("sys_msync").return ?
{
	name = "msync"
	retstr = returnstr(1)
}

# munlock ____________________________________________________
# long sys_munlock(unsigned long start, size_t len)
probe nd_syscall.munlock = kprobe.function("sys_munlock") ?
{
	name = "munlock"
	asmlinkage()
	addr = ulong_arg(1)
	len = ulong_arg(2)
	argstr = sprintf("%p, %d", addr, len)
}
probe nd_syscall.munlock.return = kprobe.function("sys_munlock").return ?
{
	name = "munlock"
	retstr = returnstr(1)
}

# munlockall _________________________________________________
# long sys_munlockall(void)
probe nd_syscall.munlockall = kprobe.function("sys_munlockall") ?
{
	name = "munlockall"
	argstr = ""
}
probe nd_syscall.munlockall.return = kprobe.function("sys_munlockall").return ?
{
	name = "munlockall"
	retstr = returnstr(1)
}

# munmap _____________________________________________________
# long sys_munmap(unsigned long addr, size_t len)
probe nd_syscall.munmap = kprobe.function("sys_munmap") ?
{
	name = "munmap"
	asmlinkage()
	start = ulong_arg(1)
	length = ulong_arg(2)
	argstr = sprintf("%p, %u", start, length)
}
probe nd_syscall.munmap.return = kprobe.function("sys_munmap").return ?
{
	name = "munmap"
	retstr = returnstr(1)
}
