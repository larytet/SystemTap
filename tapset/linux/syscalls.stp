
# ioperm _____________________________________________________
# long sys_ioperm(unsigned long from, unsigned long num, int turn_on)
#
probe syscall.ioperm = kernel.function("sys_ioperm").call ?
{
	name = "ioperm"
	from = __ulong($from)
	num = __ulong($num)
	turn_on = __uint32($turn_on)
	argstr = sprintf("%#x, %#x, %#x", from, num, turn_on)
}
probe syscall.ioperm.return = kernel.function("sys_ioperm").return ?
{
	name = "ioperm"
	retstr = return_str(1, $return)
}

# io_setup ___________________________________________________
# long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
# long compat_sys_io_setup(unsigned nr_reqs, u32 __user *ctx32p)
#
probe syscall.io_setup = __syscall.io_setup,
	__syscall.compat_io_setup ?
{
	name = "io_setup"

}
probe __syscall.io_setup = kernel.function("sys_io_setup").call
{
	@__syscall_gate(@const("__NR_io_setup"))
	maxevents = __uint32($nr_events)
	ctxp_uaddr = $ctxp
	argstr = sprintf("%u, %p", maxevents, ctxp_uaddr)
}
probe __syscall.compat_io_setup = kernel.function("compat_sys_io_setup").call
{
	maxevents = __uint32($nr_reqs)
	ctxp_uaddr = $ctx32p
	argstr = sprintf("%u, %p", maxevents, ctxp_uaddr)
}
probe syscall.io_setup.return = __syscall.io_setup.return,
	kernel.function("compat_sys_io_setup").return ?
{
	name = "io_setup"
	retstr = return_str(1, $return)
}

probe __syscall.io_setup.return = kernel.function("sys_io_setup").return
{
	@__syscall_gate(@const("__NR_io_setup"))
}

# io_submit __________________________________________________
# long compat_sys_io_submit(aio_context_t ctx_id, int nr, u32 __user *iocb)
# long sys_io_submit(aio_context_t ctx_id, long nr, struct iocb __user * __user *iocbpp)
#
probe syscall.io_submit = __syscall.io_submit,
	kernel.function("compat_sys_io_submit").call ?
{
	name = "io_submit"
	ctx_id = __ulong($ctx_id)
	nr = @__compat_long($nr)
	iocbpp_uaddr = @choose_defined($iocbpp, $iocb)
	argstr = sprintf("%u, %d, %p", ctx_id, nr, iocbpp_uaddr)
}
probe __syscall.io_submit = kernel.function("sys_io_submit").call
{
	@__syscall_gate(@const("__NR_io_submit"))
}
probe syscall.io_submit.return = __syscall.io_submit.return,
	kernel.function("compat_sys_io_submit").return ?
{
	name = "io_submit"
	retstr = return_str(1, $return)
}
probe __syscall.io_submit.return = kernel.function("sys_io_submit").return
{
	@__syscall_gate(@const("__NR_io_submit"))
}

# ioprio_get _________________________________________________
# long sys_ioprio_get(int which, int who)
#
probe syscall.ioprio_get = kernel.function("sys_ioprio_get").call ?
{
	name = "ioprio_get"
	which = __int32($which)
	which_str = _stp_ioprio_which_str(__int32($which))
	who = __int32($who)
	argstr = sprintf("%s, %d", _stp_ioprio_which_str(__int32($which)),
			 __int32($who))
}
probe syscall.ioprio_get.return = kernel.function("sys_ioprio_get").return ?
{
	name = "ioprio_get"
	retstr = return_str(1, $return)
}

# ioprio_set _________________________________________________
# long sys_ioprio_set(int which, int who, int ioprio)
#
probe syscall.ioprio_set = kernel.function("sys_ioprio_set").call ?
{
	name = "ioprio_set"
	which = __int32($which)
	which_str = _stp_ioprio_which_str(__int32($which))
	who = __int32($who)
	ioprio = __int32($ioprio)
	ioprio_str = _stp_ioprio_value_str(__int32($ioprio))
	argstr = sprintf("%s, %d, %s", _stp_ioprio_which_str(__int32($which)),
			 __int32($who),
			 _stp_ioprio_value_str(__int32($ioprio)))
}
probe syscall.ioprio_set.return = kernel.function("sys_ioprio_set").return ?
{
	name = "ioprio_set"
	retstr = return_str(1, $return)
}

# kcmp _______________________________________________________
# SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,
#                 unsigned long, idx1, unsigned long, idx2)
probe syscall.kcmp = kernel.function("sys_kcmp") ?
{
	name = "kcmp"
	pid1 = __int32($pid1)
	pid2 = __int32($pid2)
	type = __int32($type)
	type_str = _kcmp_type_str(type)
	idx1 = @__compat_ulong($idx1)
	idx2 = @__compat_ulong($idx2)
	argstr = sprintf("%d, %d, %s, %u, %u", pid1, pid2, type_str, idx1, idx2)
}
probe syscall.kcmp.return = kernel.function("sys_kcmp").return ?
{
	name = "kcmp"
	retstr = return_str(1, $return)
}

# kexec_file_load ____________________________________________
# The kexec_file_load() system call first appeared in Linux 3.17
# SYSCALL_DEFINE5(kexec_file_load, int, kernel_fd, int, initrd_fd,
#		  unsigned long, cmdline_len, const char __user *, cmdline_ptr,
#		  unsigned long, flags)
probe syscall.kexec_file_load = kernel.function("sys_kexec_file_load").call ?
{
	name = "kexec_file_load"
	kernel_fd = __int32($kernel_fd)
	initrd_fd = __int32($initrd_fd)
	cmdline_len = @__compat_ulong($cmdline_len)
	cmdline = user_string_quoted($cmdline_ptr)
	flags = @__compat_ulong($flags)
	flags_str = _kexec_file_load_flags_str(flags)
	argstr = sprintf("%d, %d, %u, %s, %s", kernel_fd, initrd_fd, cmdline_len,
			 cmdline, _kexec_file_load_flags_str(flags))
}
probe syscall.kexec_file_load.return = 
	kernel.function("sys_kexec_file_load").return ?
{
	name = "kexec_file_load"
	retstr = return_str(1, $return)
}

# kexec_load _________________________________________________
# long sys_kexec_load(unsigned long entry,
#                unsigned long nr_segments,
#                struct kexec_segment __user *segments,
#                unsigned long flags)
# long compat_sys_kexec_load(unsigned long entry,
#		unsigned long nr_segments,
#		struct compat_kexec_segment __user *segments,
#		unsigned long flags)
#
probe syscall.kexec_load = __syscall.kexec_load.call ?,
                           kernel.function("compat_sys_kexec_load").call ?
{
	name = "kexec_load"
	entry = __ulong($entry)
	nr_segments = __ulong($nr_segments)
	segments_uaddr = $segments
	flags = __ulong($flags)
	flags_str = _kexec_flags_str(flags)
	argstr = sprintf("%p, %u, %p, %s", entry, nr_segments, segments_uaddr, flags_str)
}
probe __syscall.kexec_load.call = kernel.function("sys_kexec_load").call
{
	@__syscall_gate_compat_simple
}
probe syscall.kexec_load.return = __syscall.syscall.kexec_load.return ?,
                                  kernel.function("compat_sys_kexec_load").return ?
{
	name = "kexec_load"
	retstr = return_str(1, $return)
}
probe __syscall.syscall.kexec_load.return = kernel.function("sys_kexec_load").return
{
	@__syscall_gate_compat_simple
}

# keyctl _____________________________________________________
# long sys_keyctl(int option,
#            unsigned long arg2,
#            unsigned long arg3,
#            unsigned long arg4,
#            unsigned long arg5)
# long compat_sys_keyctl(u32 option, u32 arg2, u32 arg3, u32 arg4, u32 arg5)
#
probe syscall.keyctl = kernel.function("compat_sys_keyctl").call ?,
                       kernel.function("sys_keyctl").call ?
{
	name = "keyctl"
	option = __int32($option)
	arg2 = @__compat_ulong($arg2)
	arg3 = @__compat_ulong($arg3)
	arg4 = @__compat_ulong($arg4)
	arg5 = @__compat_ulong($arg5)
	@__keyctl_argstr(option, arg2, arg3, arg4, arg5)
}
probe syscall.keyctl.return = kernel.function("compat_sys_keyctl").return ?,
                              kernel.function("sys_keyctl").return ?
{
	name = "keyctl"
	retstr = return_str(1, $return)
}

# kill _______________________________________________________
# long sys_kill(int pid, int sig)
probe syscall.kill = kernel.function("sys_kill").call
{
	name = "kill"
	pid = __int32($pid)
	sig = __int32($sig)
	argstr = sprintf("%d, %s", __int32($pid), _signal_name(__int32($sig)))
}
probe syscall.kill.return = kernel.function("sys_kill").return
{
	name = "kill"
	retstr = return_str(1, $return)
}

# lchown _____________________________________________________
# long sys_lchown(const char __user * filename, uid_t user, gid_t group)
#
probe syscall.lchown = kernel.function("sys_lchown").call
{
	// Avoid lchown16() calling lchown().
%( arch == "x86_64" %?
	@__syscall_compat_gate(@const("__NR_lchown"), @const("__NR_ia32_lchown32"))
%)
%( arch == "i386" %?
	@__syscall_gate(@const("__NR_lchown32"))
%)
	name = "lchown"
	path = user_string_quoted($filename)
	owner = __int32($user)
	group = __int32($group)
	argstr = sprintf("%s, %d, %d", user_string_quoted($filename), owner, group)
}
probe syscall.lchown.return = kernel.function("sys_lchown").return
{
%( arch == "x86_64" %?
	@__syscall_compat_gate(@const("__NR_lchown"), @const("__NR_ia32_lchown32"))
%)
%( arch == "i386" %?
	@__syscall_gate(@const("__NR_lchown32"))
%)
	name = "lchown"
	retstr = return_str(1, $return)
}

# lchown16 ___________________________________________________
# long sys_lchown16(const char __user * filename, old_uid_t user,
#			old_gid_t group)
#
probe syscall.lchown16 = kernel.function("sys_lchown16").call ?
{
	name = "lchown16"
	path = user_string_quoted($filename)
	owner = __short($user)
	group = __short($group)
	argstr = sprintf("%s, %d, %d", user_string_quoted($filename), owner, group)
}
probe syscall.lchown16.return = kernel.function("sys_lchown16").return ?
{
	name = "lchown16"
	retstr = return_str(1, $return)
}

# lgetxattr __________________________________________________
# ssize_t sys_lgetxattr(char __user *path,
#               char __user *name,
#               void __user *value,
#               size_t size)
#
probe syscall.lgetxattr = kernel.function("sys_lgetxattr").call
{
	name = "lgetxattr"
	path = user_string_quoted(@choose_defined($pathname, $path))
# 'name2' should have been 'name_str'.  Deprecate the old name.
%(systemtap_v <= "1.4" %?
	name2 = user_string_quoted($name)
%)
	name_str = user_string_quoted($name)
	value_uaddr = $value
	size = __ulong($size)
	argstr = sprintf("%s, %s, %p, %u",
		user_string_quoted(@choose_defined($pathname, $path)),
		user_string_quoted($name),
		value_uaddr, size)
}
probe syscall.lgetxattr.return = kernel.function("sys_lgetxattr").return
{
	name = "lgetxattr"
	retstr = return_str(1, $return)
}

# link _______________________________________________________
# long sys_link(const char __user * oldname,
#          const char __user * newname)
probe syscall.link = kernel.function("sys_link").call
{
	name = "link"
	oldpath = user_string_quoted($oldname)
	newpath = user_string_quoted($newname)
	argstr = sprintf("%s, %s",
		user_string_quoted($oldname),
		user_string_quoted($newname))
}
probe syscall.link.return = kernel.function("sys_link").return
{
	name = "link"
	retstr = return_str(1, $return)
}

# linkat _____________________________________________________
# new function with 2.6.16
# long sys_linkat(int olddfd, const char __user *oldname,
#	int newdfd, const char __user *newname, int flags)
probe syscall.linkat = kernel.function("sys_linkat").call ?
{
	@__syscall_compat_gate(@const("__NR_linkat"), @const("__NR_compat_linkat"))
	name = "linkat"
	olddirfd = __int32($olddfd)
	olddirfd_str = _dfd_str(__int32($olddfd))
	oldpath = user_string_quoted($oldname)
	newdirfd = __int32($newdfd)
	newdirfd_str = _dfd_str(__int32($newdfd))
	newpath = user_string_quoted($newname)
	flags = __int32($flags)
	flags_str = _at_flag_str(__int32($flags))
	argstr = sprintf("%s, %s, %s, %s, %s",
			 olddirfd_str, user_string_quoted($oldname),
			 newdirfd_str, user_string_quoted($newname),
			 flags_str)
}
probe syscall.linkat.return = kernel.function("sys_linkat").return ?
{
	@__syscall_compat_gate(@const("__NR_linkat"), @const("__NR_compat_linkat"))
	name = "linkat"
	retstr = return_str(1, $return)
}

# listen _____________________________________________________
# long sys_listen(int fd, int backlog)
probe syscall.listen = __syscall.listen ?, __syscall.socketcall.listen ?,
	__syscall.compat_socketcall.listen ?
{
	name = "listen"
	argstr = sprintf("%d, %d", sockfd, backlog)
}
probe __syscall.listen = kernel.function("sys_listen").call ?
{
	@__syscall_gate(@const("__NR_listen"))
	sockfd = __int32($fd)
	backlog = __int32($backlog)
}
probe __syscall.socketcall.listen = kernel.function("sys_socketcall").call ?
{
	if ($call != @const("SYS_LISTEN")) next;
	sockfd = __int32(user_ulong(&@cast($args, "ulong")[0]))
	backlog = __int32(user_ulong(&@cast($args, "ulong")[1]))
}
probe __syscall.compat_socketcall.listen =
	kernel.function("compat_sys_socketcall").call ?
{
	if ($call != @const("SYS_LISTEN")) next;
	sockfd = user_int(&@cast($args, "unsigned int")[0])
	backlog = user_int(&@cast($args, "unsigned int")[1])
}
probe syscall.listen.return = __syscall.listen.return ?,
	__syscall.socketcall.listen.return ?
{
	name = "listen"
	retstr = return_str(1, $return)
}
probe __syscall.listen.return = kernel.function("sys_listen").return ?
{
	@__syscall_gate(@const("__NR_listen"))
}
probe __syscall.socketcall.listen.return =
	kernel.function("sys_socketcall").return ?,
	kernel.function("compat_sys_socketcall").return ?
{
	if (@entry($call) != @const("SYS_LISTEN")) next;
}

# listxattr __________________________________________________
# ssize_t sys_listxattr(char __user *path, char __user *list, size_t size)
#
probe syscall.listxattr = kernel.function("sys_listxattr").call
{
	name = "listxattr"
	list_uaddr = $list
	size = __ulong($size)
	path_uaddr = @choose_defined($pathname, $path)
	path = user_string_quoted(@choose_defined($pathname, $path))
	argstr = sprintf("%s, %p, %u",
		user_string_quoted(@choose_defined($pathname, $path)),
		$list, __ulong($size))
}
probe syscall.listxattr.return = kernel.function("sys_listxattr").return
{
	name = "listxattr"
	retstr = return_str(1, $return)
}

# llistxattr _________________________________________________
# ssize_t sys_llistxattr(char __user *path, char __user *list, size_t size)
#
probe syscall.llistxattr = kernel.function("sys_llistxattr").call
{
	name = "llistxattr"
	list_uaddr = $list
	size = __ulong($size)
	path_uaddr = @choose_defined($pathname, $path)
	path = user_string_quoted(@choose_defined($pathname, $path))
	argstr = sprintf("%s, %p, %u",
		user_string_quoted(@choose_defined($pathname, $path)),
		$list, __ulong($size))
}
probe syscall.llistxattr.return = kernel.function("sys_llistxattr").return
{
	name = "llistxattr"
	retstr = return_str(1, $return)
}

# llseek _____________________________________________________
# long sys_llseek(unsigned int fd,
#            unsigned long offset_high,
#            unsigned long offset_low,
#            loff_t __user * result,
#            unsigned int whence)
probe syscall.llseek = kernel.function("sys_llseek").call ?
{
	name = "llseek"
	fd = __int32($fd)
	offset_high = $offset_high
	offset_low = $offset_low
	result_uaddr = $result
	whence = @choose_defined($whence, $origin)
	whence_str = _seek_whence_str(@choose_defined($whence, $origin))
	argstr = sprintf("%d, 0x%x, 0x%x, %p, %s", fd, $offset_high,
		$offset_low, $result, whence_str)
}
probe syscall.llseek.return = kernel.function("sys_llseek").return ?
{
	name = "llseek"
	retstr = return_str(1, $return)
}

# lookup_dcookie _____________________________________________
# long sys_lookup_dcookie(u64 cookie64, char __user * buf, size_t len)
#
probe syscall.lookup_dcookie = kernel.function("sys_lookup_dcookie").call ?
{
	@__syscall_gate_compat_simple
	name = "lookup_dcookie"
	cookie = $cookie64
	buffer_uaddr = $buf
	len = __ulong($len)
	argstr = sprintf("%#lx, %p, %#x", $cookie64, $buf, $len)
}
probe syscall.lookup_dcookie.return = kernel.function("sys_lookup_dcookie").return ?
{
	@__syscall_gate_compat_simple
	name = "lookup_dcookie"
	retstr = return_str(1, $return)
}

# lremovexattr _______________________________________________
# long sys_lremovexattr(char __user *path, char __user *name)
#
probe syscall.lremovexattr = kernel.function("sys_lremovexattr").call
{
	name = "lremovexattr"
	name_uaddr = $name
# 'name2' should have been 'name_str'.  Deprecate the old name.
%(systemtap_v <= "1.4" %?
	name2 = user_string_quoted($name)
%)
	name_str = user_string_quoted($name)
	path_uaddr = @choose_defined($pathname, $path)
	path = user_string_quoted(@choose_defined($pathname, $path))
	argstr = sprintf("%s, %s",
		user_string_quoted(@choose_defined($pathname, $path)),
		user_string_quoted($name))
}
probe syscall.lremovexattr.return = kernel.function("sys_lremovexattr").return
{
	name = "lremovexattr"
	retstr = return_str(1, $return)
}

# lseek ______________________________________________________
# off_t sys_lseek(unsigned int fd, off_t offset, unsigned int whence)
# COMPAT_SYSCALL_DEFINE3(lseek, unsigned int, fd, compat_off_t, offset,
#			 unsigned int, whence)
#
probe syscall.lseek = kernel.function("sys_lseek").call ?,
                      kernel.function("compat_sys_lseek").call ?
{
	name = "lseek"
	fildes = __int32($fd)
	offset = @__compat_long($offset)
	whence = @__compat_ulong(@choose_defined($whence, $origin))
	whence_str = _seek_whence_str(whence)
	argstr = sprintf("%d, %d, %s", fildes, offset, whence_str)
}
probe syscall.lseek.return = kernel.function("sys_lseek").return,
			     kernel.function("compat_sys_lseek").return ?
{
	name = "lseek"
	retstr = return_str(1, $return)
}

# lsetxattr __________________________________________________
# long sys_lsetxattr(char __user *path,
#               char __user *name,
#               void __user *value,
#               size_t size,
#               int flags)
#
probe syscall.lsetxattr = kernel.function("sys_lsetxattr").call
{
	name = "lsetxattr"
	path_uaddr = @choose_defined($pathname, $path)
	path = user_string_quoted(@choose_defined($pathname, $path))
	name_uaddr = $name
	name_str = user_string_quoted($name)
	value_uaddr = $value
	size = __ulong($size)
	value_str = _stp_xattr_val_str($value, size)
	flags = __int32($flags)
	flags_str = _stp_xattr_flags_str(__int32($flags))
	argstr = sprintf("%s, %s, %s, %u, %s",
			user_string_quoted(@choose_defined($pathname, $path)),
			user_string_quoted($name),
			_stp_xattr_val_str($value, $size), __ulong($size),
			_stp_xattr_flags_str(__int32($flags)))
}
probe syscall.lsetxattr.return = kernel.function("sys_lsetxattr").return
{
	name = "lsetxattr"
	retstr = return_str(1, $return)
}

# lstat ______________________________________________________
# long sys_lstat(char __user * filename, struct __old_kernel_stat __user * statbuf)
# long sys_newlstat(char __user * filename, struct stat __user * statbuf)
# long compat_sys_newlstat(char __user * filename, struct compat_stat __user *statbuf)
# long sys32_lstat64(char * filename, struct stat64 __user *statbuf)
# long sys_lstat64(char __user * filename, struct stat64 __user * statbuf)
# long sys_oabi_lstat64(char __user * filename,
#			struct oldabi_stat64 __user * statbuf)
#
probe syscall.lstat = kernel.function("sys_lstat").call ?,
                      kernel.function("sys_newlstat").call ?,
                      kernel.function("compat_sys_newlstat").call ?,
                      kernel.function("sys32_lstat64").call ?,
                      kernel.function("sys_lstat64").call ?,
                      kernel.function("sys_oabi_lstat64").call ?
{
	name = "lstat"
	path = user_string_quoted($filename)
	buf_uaddr = $statbuf
	argstr = sprintf("%s, %p", user_string_quoted($filename), $statbuf)
}
probe syscall.lstat.return = kernel.function("sys_lstat").return ?,
                             kernel.function("sys_newlstat").return ?,
                             kernel.function("compat_sys_newlstat").return ?,
                             kernel.function("sys32_lstat64").return ?,
                             kernel.function("sys_lstat64").return ?,
                             kernel.function("sys_oabi_lstat64").return ?
{
	name = "lstat"
	retstr = return_str(1, $return)
}

# madvise ____________________________________________________
# long sys_madvise(unsigned long start, size_t len_in, int behavior)
#
probe syscall.madvise = kernel.function("sys_madvise").call ?
{
	name = "madvise"
	start = __ulong($start)
	length = __ulong($len_in)
	advice = __int32($behavior)
	advice_str = _madvice_advice_str(advice)
	argstr = sprintf("%p, %u, %s", start, length,
			 _madvice_advice_str(advice))
}
probe syscall.madvise.return = kernel.function("sys_madvise").return ?
{
	name = "madvise"
	retstr = return_str(1, $return)
}

# mbind ______________________________________________________
# long sys_mbind(unsigned long start,
#	unsigned long len,
#	unsigned long mode,
#	unsigned long __user *nmask,
#	unsigned long maxnode,
#	unsigned flags)
#
# long compat_sys_mbind(compat_ulong_t start,
#	compat_ulong_t len,
#	compat_ulong_t mode,
#	compat_ulong_t __user *nmask,
#	compat_ulong_t maxnode,
#	compat_ulong_t flags)
#
probe syscall.mbind = __syscall.mbind ?,
                      kernel.function("compat_sys_mbind").call ?
{
	name = "mbind"
	start = $start
	mode = __int32($mode)
	mode_str = _mempolicy_mode_str(mode)
	nmask_uaddr = $nmask
	flags = __uint32($flags)
	flags_str = _mempolicy_flags_str(flags)
	len = @__compat_ulong($len)
	maxnode = @__compat_ulong($maxnode)
	argstr = sprintf("%p, %u, %s, %p, %u, %s", start, len,
	                 mode_str, nmask_uaddr, maxnode, flags_str)
}
probe __syscall.mbind = kernel.function("sys_mbind").call
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}
probe syscall.mbind.return = __syscall.mbind.return ?,
                             kernel.function("compat_sys_mbind").return ?
{
	name = "mbind"
	retstr = return_str(1, $return)
}
probe __syscall.mbind.return = kernel.function("sys_mbind").return
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}

# membarrier _______________________________________________________
# SYSCALL_DEFINE2(membarrier, int, cmd, int, flags)
probe syscall.membarrier = kernel.function("sys_membarrier").call ?
{
	name = "membarrier"
	cmd = __int32($cmd)
	cmd_str = _membarrier_cmd_str(cmd)
	flags = __int32($flags)
	argstr = sprintf("%s, %d", _membarrier_cmd_str(cmd),
			 __int32($flags))
}
probe syscall.membarrier.return = kernel.function("sys_membarrier").return ?
{
	name = "membarrier"
	retstr = return_str(1, $return)
}

# memfd_create _____________________________________________________
# long sys_memfd_create (const char __user* uname, unsigned int flags)
probe syscall.memfd_create = kernel.function("sys_memfd_create").call ?
{
	name = "memfd_create"
	uname = user_string_quoted($uname)
	flags = $flags
	flags_str = _mfd_flags_str($flags)
	argstr = sprintf("%s, %s", user_string_quoted($uname), flags_str)
}
probe syscall.memfd_create.return = kernel.function("sys_memfd_create").return ?
{
	name = "memfd_create"
	retstr = return_str(1, $return)
}

# migrate_pages ____________________________________________________
# long sys_migrate_pages(pid_t pid, unsigned long maxnode,
#		const unsigned long __user *old_nodes,
#		const unsigned long __user *new_nodes)
probe syscall.migrate_pages = __syscall.migrate_pages ?,
                              kernel.function("compat_sys_migrate_pages").call ?
{
	name = "migrate_pages"
	pid = __int32($pid)
	old_nodes = $old_nodes
	new_nodes = $new_nodes
	maxnode = @__compat_ulong($maxnode)
	argstr = sprintf("%d, %u, %p, %p", pid, maxnode, old_nodes, new_nodes)
}
probe __syscall.migrate_pages = kernel.function("sys_migrate_pages").call
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}
probe syscall.migrate_pages.return = __syscall.migrate_pages.return ?,
                                     kernel.function("compat_sys_migrate_pages").return ?
{
	name = "migrate_pages"
	retstr = return_str(1, $return)
}
probe __syscall.migrate_pages.return = kernel.function("sys_migrate_pages").return
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}

# mincore ____________________________________________________
# long sys_mincore(unsigned long start, size_t len, unsigned char __user * vec)
#
probe syscall.mincore = kernel.function("sys_mincore").call ?
{
	name = "mincore"
	start = $start
	length = __ulong($len)
	vec_uaddr = $vec
	argstr = sprintf("%p, %u, %p", start, length, vec_uaddr)
}
probe syscall.mincore.return = kernel.function("sys_mincore").return ?
{
	name = "mincore"
	retstr = return_str(1, $return)
}

# mkdir ______________________________________________________
# long sys_mkdir(const char __user * pathname, int mode)
probe syscall.mkdir = kernel.function("sys_mkdir").call
{
	name = "mkdir"
	pathname_uaddr = $pathname
	pathname = user_string_quoted($pathname)
	mode = __uint32($mode)
	argstr = sprintf("%s, %#o", user_string_quoted($pathname),
			 __uint32($mode))
}
probe syscall.mkdir.return = kernel.function("sys_mkdir").return
{
	name = "mkdir"
	retstr = return_str(1, $return)
}

# mkdirat ____________________________________________________
# new function with 2.6.16
# long sys_mkdirat(int dfd, const char __user *pathname, int mode)
probe syscall.mkdirat = kernel.function("sys_mkdirat").call ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	dirfd = __int32($dfd)
	dirfd_str = _dfd_str(__int32($dfd))
	pathname = user_string_quoted($pathname)
	mode = __uint32($mode)
	argstr = sprintf("%s, %s, %#o", _dfd_str(__int32($dfd)),
			 user_string_quoted($pathname), __uint32($mode))
}
probe syscall.mkdirat.return = kernel.function("sys_mkdirat").return ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	retstr = return_str(1, $return)
}

# mknod ______________________________________________________
# long sys_mknod(const char __user * filename, int mode, unsigned dev)
probe syscall.mknod = kernel.function("sys_mknod").call
{
	name = "mknod"
	pathname = user_string_quoted($filename)
	mode = __uint32($mode)
	dev = __uint32($dev)
	argstr = sprintf("%s, %s, %u", pathname, _mknod_mode_str(mode), dev)
}

probe syscall.mknod.return = kernel.function("sys_mknod").return
{
	name = "mknod"
	retstr = return_str(1, $return)
}

# mknodat ____________________________________________________
# new function with 2.6.16
# long sys_mknodat(int dfd, const char __user *filename,
#	int mode, unsigned dev)
probe syscall.mknodat = kernel.function("sys_mknodat").call ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	dirfd = __int32($dfd)
	dirfd_str = _dfd_str(dirfd)
	pathname = user_string_quoted($filename)
	mode = __uint32($mode)
	mode_str = _mknod_mode_str(mode)
	dev = __uint32($dev)
	argstr = sprintf("%s, %s, %s, %u",
		dirfd_str, pathname, mode_str, dev)
}
probe syscall.mknodat.return = kernel.function("sys_mknodat").return ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	retstr = return_str(1, $return)
}

# mlock ______________________________________________________
#
# long sys_mlock(unsigned long start, size_t len)
#
probe syscall.mlock = kernel.function("sys_mlock").call ?
{
	name = "mlock"
	addr = __ulong($start)
	len = __ulong($len)
	argstr = sprintf("%p, %u", addr, len)
}
probe syscall.mlock.return = kernel.function("sys_mlock").return ?
{
	name = "mlock"
	retstr = return_str(1, $return)
}

# mlock2 _____________________________________________________
#
# long sys_mlock2(unsigned long start, size_t len, int flags)
#
probe syscall.mlock2 = kernel.function("sys_mlock2").call ?
{
	name = "mlock2"
	addr = __ulong($start)
	len = __ulong($len)
	flags = __int32($flags)
	flags_str = _stp_mlock2_str(__int32($flags))
	argstr = sprintf("%p, %u, %s", addr, len, flags_str)
}
probe syscall.mlock2.return = kernel.function("sys_mlock2").return ?
{
	name = "mlock2"
	retstr = return_str(1, $return)
}

# mlockall ___________________________________________________
#
# long sys_mlockall(int flags)
#
probe syscall.mlockall = kernel.function("sys_mlockall").call ?
{
	name = "mlockall"
	flags = __int32($flags)
	argstr = _mlockall_flags_str(flags)
}
probe syscall.mlockall.return = kernel.function("sys_mlockall").return ?
{
	name = "mlockall"
	retstr = return_str(1, $return)
}

# modify_ldt _________________________________________________
# int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
#
probe syscall.modify_ldt = kernel.function("sys_modify_ldt").call ?
{
	name = "modify_ldt"
	func = __int32($func)
	ptr_uaddr = $ptr
	bytecount = __ulong($bytecount)
	argstr = sprintf("%d, %p, %u", $func, $ptr, __ulong($bytecount))
}
probe syscall.modify_ldt.return = kernel.function("sys_modify_ldt").return ?
{
	name = "modify_ldt"
	retstr = return_str(1, $return)
}

# move_pages ____________________________________________________
# long sys_move_pages(pid_t pid, unsigned long nr_pages,
#			const void __user * __user *pages,
#			const int __user *nodes,
#			int __user *status,
#			int flags)
#
# long compat_sys_move_pages(pid_t pid, unsigned long nr_pages,
#                compat_uptr_t __user *pages32,
#                const int __user *nodes,
#                int __user *status,
#                int flags)
#
probe syscall.move_pages = __syscall.move_pages ?,
                           kernel.function("compat_sys_move_pages").call ?
{
	name = "move_pages"
	pages = @choose_defined($pages32, $pages)
	pid = __int32($pid)
	nodes = $nodes
	status = $status
	flags = __int32($flags)
	flags_str = _mempolicy_flags_str(flags)
	nr_pages = @__compat_ulong($nr_pages)
	argstr = sprintf("%d, %u, %p, %p, %p, %s", pid, nr_pages, pages,
	                 nodes, status, flags_str)
}
probe __syscall.move_pages = kernel.function("sys_move_pages").call
{
	@__syscall_gate(@const("__NR_move_pages"))
}
probe syscall.move_pages.return = __syscall.move_pages.return ?,
                                  kernel.function("compat_sys_move_pages").return ?
{
	name = "move_pages"
	retstr = return_str(1, $return)
}
probe __syscall.move_pages.return = kernel.function("sys_move_pages").return
{
	@__syscall_gate(@const("__NR_move_pages"))
}

# mount ______________________________________________________
# long sys_mount(char __user * dev_name,
# 		char __user * dir_name,
# 		char __user * type,
# 		unsigned long flags,
# 		void __user * data)
# long compat_sys_mount(char __user * dev_name,
#		char __user * dir_name,
#		char __user * type,
#		unsigned long flags,
#		void __user * data)
probe syscall.mount = kernel.function("compat_sys_mount").call ?,
                      kernel.function("sys_mount").call
{
	name = "mount"
	source = user_string_quoted($dev_name)
	target = user_string_quoted($dir_name)
	filesystemtype = user_string_quoted($type)
	mountflags = $flags
	mountflags_str = _mountflags_str($flags)
	data = user_string_n_quoted($data, syscall_string_trunc)
	argstr = sprintf("%s, %s, %s, %s, %s",
		user_string_quoted($dev_name),
		user_string_quoted($dir_name),
		user_string_quoted($type),
		mountflags_str, data)
}
probe syscall.mount.return = kernel.function("compat_sys_mount").return ?,
                             kernel.function("sys_mount").return
{
	name = "mount"
	retstr = return_str(1, $return)
}

%( kernel_v >= "2.6.33" %?
# In newer kernels (2.6.33+), all the sys_mmap() variants are just 
# wrappers around sys_mmap_pgoff(), which is in arch-generic code.
#
# long sys_mmap_pgoff(unsigned long addr, unsigned long len,
#		unsigned long prot, unsigned long flags,
#		unsigned long fd, unsigned long pgoff)
probe syscall.mmap2 = kernel.function("sys_mmap_pgoff") ?
{
	name = "mmap2"
	start = $addr
	length = __ulong($len)
	prot = $prot
	flags = $flags
	# Although the kernel gets an unsigned long fd, on the
	# user-side it is a signed int.  Fix this.
	fd = __int32($fd)
	# $pgoff is the number of pages. Convert this back into a
	# number of bytes.
	pgoffset = $pgoff * @const("PAGE_SIZE")
	argstr = sprintf("%p, %u, %s, %s, %d, %d", $addr, __ulong($len),
		_mprotect_prot_str($prot), _mmap_flags($flags),
		__int32($fd), pgoffset)
}
probe syscall.mmap2.return = kernel.function("sys_mmap_pgoff").return ?
{
        name = "mmap2"
        retstr = return_str(2, $return)
}
%)

# mprotect ___________________________________________________
# long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
#
probe syscall.mprotect = kernel.function("sys_mprotect").call ?
{
	name = "mprotect"
	addr = $start
	len = $len
	prot = $prot
	prot_str = _mprotect_prot_str($prot)
	argstr = sprintf("%p, %d, %s", $start, $len, _mprotect_prot_str($prot))
}
probe syscall.mprotect.return = kernel.function("sys_mprotect").return ?
{
	name = "mprotect"
	retstr = return_str(1, $return)
}

# mq_getsetattr ______________________________________________
# long sys_mq_getsetattr(mqd_t mqdes,
#                  const struct mq_attr __user *u_mqstat,
#                  struct mq_attr __user *u_omqstat)
# long compat_sys_mq_getsetattr(mqd_t mqdes,
#			const struct compat_mq_attr __user *u_mqstat,
#			struct compat_mq_attr __user *u_omqstat)
#
probe syscall.mq_getsetattr =
        __syscall.mq_getsetattr,
        kernel.function("compat_sys_mq_getsetattr").call ?
{
	name = "mq_getsetattr"
	mqdes = __int32($mqdes)
	u_mqstat_uaddr = $u_mqstat
	u_omqstat_uaddr = $u_omqstat
	argstr = sprintf("%d, %p, %p", mqdes, u_mqstat_uaddr, u_omqstat_uaddr)
}
probe __syscall.mq_getsetattr = kernel.function("sys_mq_getsetattr").call
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}
probe syscall.mq_getsetattr.return =
        __syscall.mq_getsetattr.return,
        kernel.function("compat_sys_mq_getsetattr").return ?
{
	name = "mq_getsetattr"
	retstr = return_str(1, $return)
}
probe __syscall.mq_getsetattr.return = kernel.function("sys_mq_getsetattr").return
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}

# mq_notify __________________________________________________
# long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
# long compat_sys_mq_notify(mqd_t mqdes, const struct compat_sigevent __user *u_notification)
#
probe syscall.mq_notify =
        __syscall.mq_notify,
        kernel.function("compat_sys_mq_notify").call ?
{
	name = "mq_notify"
	mqdes = __int32($mqdes)
	notification_uaddr = $u_notification
	argstr = sprintf("%d, %p", mqdes, $u_notification)
}
probe __syscall.mq_notify = kernel.function("sys_mq_notify").call
{
        @__syscall_gate(@const("__NR_mq_notify"))
}
probe syscall.mq_notify.return =
        __syscall.mq_notify.return,
        kernel.function("compat_sys_mq_notify").return ?
{
	name = "mq_notify"
	retstr = return_str(1, $return)
}
probe __syscall.mq_notify.return = kernel.function("sys_mq_notify").return
{
        @__syscall_gate(@const("__NR_mq_notify"))
}

# mq_open ____________________________________________________
# long  sys_mq_open(const char __user *u_name,
#             int oflag,
#             mode_t mode,
#             struct mq_attr __user *u_attr)
# long compat_sys_mq_open(const char __user *u_name,
#			int oflag, compat_mode_t mode,
#			struct compat_mq_attr __user *u_attr)
#
probe syscall.mq_open = __syscall.mq_open,
                        kernel.function("compat_sys_mq_open").call ?
{
	name = "mq_open"
	name_uaddr = $u_name
	filename = user_string_quoted($u_name)
	u_attr_uaddr = $u_attr
	oflag = __int32($oflag)
	mode = (@__compat_task ? __ushort($mode) : __uint32($mode))
	if (oflag & 64)
		argstr = sprintf("%s, %s, %#o, %p", user_string_quoted($u_name),
			_sys_open_flag_str(oflag), mode, $u_attr)
	else
		argstr = sprintf("%s, %s", user_string_quoted($u_name), _sys_open_flag_str(oflag))
}

probe __syscall.mq_open = kernel.function("sys_mq_open").call
{
	@__syscall_gate_compat_simple
}
probe syscall.mq_open.return =
        __syscall.mq_open.return,
        kernel.function("compat_sys_mq_open").return ?
{
	name = "mq_open"
	retstr = return_str(1, $return)
}
probe __syscall.mq_open.return = kernel.function("sys_mq_open").return
{
        @__syscall_gate(@const("__NR_mq_open"))
}

# mq_timedreceive ____________________________________________
# ssize_t sys_mq_timedreceive(mqd_t mqdes,
#                     char __user *u_msg_ptr,
#                     size_t msg_len,
#                     unsigned int __user *u_msg_prio,
#                     const struct timespec __user *u_abs_timeout)
# ssize_t compat_sys_mq_timedreceive(mqd_t mqdes,
#			char __user *u_msg_ptr,
#			size_t msg_len, unsigned int __user *u_msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe syscall.mq_timedreceive =
	__syscall.mq_timedreceive ?,
	kernel.function("compat_sys_mq_timedreceive").call ?
{
	name = "mq_timedreceive"
	mqdes = __int32($mqdes)
	msg_ptr_uaddr = $u_msg_ptr
	msg_prio_uaddr = $u_msg_prio
	abs_timeout_uaddr = $u_abs_timeout
%( CONFIG_64BIT == "y" %?
	msg_len = @__compat_ulong($msg_len)
%:
	msg_len = __uint32($msg_len)
%)
	argstr = sprintf("%d, %p, %u, %p, %p", mqdes, $u_msg_ptr, msg_len,
		$u_msg_prio, $u_abs_timeout)
}
probe __syscall.mq_timedreceive = kernel.function("sys_mq_timedreceive").call
{
        @__syscall_gate(@const("__NR_mq_timedreceive"))
}
probe syscall.mq_timedreceive.return =
        __syscall.mq_timedreceive.return,
        kernel.function("compat_sys_mq_timedreceive").return ?
{
	name = "mq_timedreceive"
	retstr = return_str(1, $return)
}
probe __syscall.mq_timedreceive.return = kernel.function("sys_mq_timedreceive").return
{
	@__syscall_gate_compat_simple
}

# mq_timedsend _______________________________________________
# long sys_mq_timedsend(mqd_t mqdes,
#                  const char __user *u_msg_ptr,
#                  size_t msg_len,
#                  unsigned int msg_prio,
#                  const struct timespec __user *u_abs_timeout)
#  long compat_sys_mq_timedsend(mqd_t mqdes,
#			const char __user *u_msg_ptr,
#			size_t msg_len, unsigned int msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe syscall.mq_timedsend =
	__syscall.mq_timedsend,
	kernel.function("compat_sys_mq_timedsend").call ?
{
	name = "mq_timedsend"
	mqdes = __int32($mqdes)
	msg_ptr_uaddr = $u_msg_ptr
	msg_prio = __uint32($msg_prio)
	abs_timeout_uaddr = $u_abs_timeout
%( CONFIG_64BIT == "y" %?
	msg_len = @__compat_ulong($msg_len)
%:
	msg_len = __uint32($msg_len)
%)
	argstr = sprintf("%d, %p, %u, %u, %p", mqdes, $u_msg_ptr, msg_len,
		__uint32($msg_prio), $u_abs_timeout)
}
probe __syscall.mq_timedsend = kernel.function("sys_mq_timedsend").call
{
        @__syscall_gate(@const("__NR_mq_timedsend"))
}
probe syscall.mq_timedsend.return =
        __syscall.mq_timedsend.return,
        kernel.function("compat_sys_mq_timedsend").return ?
{
	name = "mq_timedsend"
	retstr = return_str(1, $return)
}
probe __syscall.mq_timedsend.return = kernel.function("sys_mq_timedsend").return
{
	@__syscall_gate_compat_simple
}

# mq_unlink __________________________________________________
# long sys_mq_unlink(const char __user *u_name)
#
probe syscall.mq_unlink = kernel.function("sys_mq_unlink").call ?
{
	name = "mq_unlink"
	u_name_uaddr = $u_name
	u_name = user_string_quoted($u_name)
	argstr = user_string_quoted($u_name)
}
probe syscall.mq_unlink.return = kernel.function("sys_mq_unlink").return ?
{
	name = "mq_unlink"
	retstr = return_str(1, $return)
}

# mremap _____________________________________________________
# unsigned long sys_mremap(unsigned long addr,
#            unsigned long old_len,
#            unsigned long new_len,
#            unsigned long flags,
#            unsigned long new_addr)
#
probe syscall.mremap = kernel.function("ia64_mremap").call ?,
                       kernel.function("sys_mremap").call ?
{
	name = "mremap"
	old_address = $addr
	old_size = $old_len
	new_size = $new_len
	flags = $flags
	new_address = $new_addr
	argstr = sprintf("%p, %d, %d, %s, %p", $addr, $old_len, $new_len,
		_mremap_flags($flags), $new_addr)
}
probe syscall.mremap.return = kernel.function("ia64_mremap").return ?,
                              kernel.function("sys_mremap").return ?
{
	name = "mremap"
	retstr = return_str(2, $return)
}

# msgctl _____________________________________________________
# long sys_msgctl (int msqid, int cmd, struct msqid_ds __user *buf)
#
probe syscall.msgctl = kernel.function("sys_msgctl").call ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	msqid = __int32($msqid)
	cmd = __int32($cmd)
	cmd_str = _stp_msgctl_cmd_str(__int32($cmd))
	buf_uaddr = $buf
	argstr = sprintf("%d, %s, %p", __int32($msqid),
			 _stp_msgctl_cmd_str(__int32($cmd)), $buf)
}
probe syscall.msgctl.return = kernel.function("sys_msgctl").return ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	retstr = return_str(1, $return)
}
# compat_sys_msgctl ________________________________________
#
# long compat_sys_msgctl(int first, int second, void __user *uptr)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgctl = __syscall.compat_msgctl ?,
      __syscall.compat_ipc.msgctl ?
{
	name = "msgctl"
	cmd_str = _stp_msgctl_cmd_str(cmd)
	argstr = sprintf("%d, %s, %p", msqid, _stp_msgctl_cmd_str(cmd),
			 buf_uaddr)
}
probe __syscall.compat_msgctl = kernel.function("compat_sys_msgctl").call ?
{
	msqid = __int32($first)
	cmd = __int32($second)
	buf_uaddr = $uptr
}
probe __syscall.compat_ipc.msgctl = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGCTL")) next;
	msqid = __int32($first)
	cmd = __int32($second)
	buf_uaddr = $ptr
}
probe syscall.compat_sys_msgctl.return =
	kernel.function("compat_sys_msgctl").return ?,
	__syscall.compat_ipc.msgctl.return ?
{
	name = "msgctl"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgctl.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGCTL")) next;
}

# msgget _____________________________________________________
# long sys_msgget (key_t key, int msgflg)
#
probe syscall.msgget = kernel.function("sys_msgget").call ?
{
	name = "msgget"
	key = __int32($key)
	key_str = _stp_msgget_key_str(__int32($key))
	msgflg = __int32($msgflg)
	msgflg_str = __sem_flags(__int32($msgflg))
	argstr = sprintf("%s, %s", _stp_msgget_key_str(__int32($key)),
			 __sem_flags(__int32($msgflg)))
}
probe syscall.msgget.return = kernel.function("sys_msgget").return ?
{
	name = "msgget"
	retstr = return_str(1, $return)
}

# msgrcv _____________________________________________________
# long sys_msgrcv (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             long msgtyp,
#             int msgflg)
#
probe syscall.msgrcv = kernel.function("sys_msgrcv").call ?
{
	name = "msgrcv"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgtyp = $msgtyp
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %d, %s", __int32($msqid), $msgp,
			 __ulong($msgsz), $msgtyp,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgrcv.return = kernel.function("sys_msgrcv").return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
# compat_sys_msgrcv ________________________________________
#
# long compat_sys_msgrcv(int first, int second, int msgtyp, int third,
#			int version, void __user *uptr)
# COMPAT_SYSCALL_DEFINE5(msgrcv, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, long, msgtyp, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgrcv = __syscall.compat_msgrcv ?,
	__syscall.compat_ipc.msgrcv ?
{
	name = "msgrcv"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %d, %s", msqid, msgp_uaddr, msgsz,
			 msgtyp, _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgrcv = kernel.function("compat_sys_msgrcv").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	if (@defined($version)) {
		msgp_uaddr = _stp_compat_msgrcv_msgbuf($uptr, $version)
		msgtyp = _stp_compat_msgrcv_msgtyp($uptr, $version, $msgtyp)
	}
	else {
		msgp_uaddr = $msgp
		msgtyp = __int32($msgtyp)
	}
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgrcv = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGRCV")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)

	# __version isn't quite correct (it should be shifted down 16
	# bits), but all we really need is zero/non-zero.
	__version = $call & 0xffff0000
	msgp_uaddr = _stp_compat_msgrcv_msgbuf($ptr, __version)
	msgtyp = _stp_compat_msgrcv_msgtyp($ptr, __version, $fifth)
}
probe syscall.compat_sys_msgrcv.return =
	kernel.function("compat_sys_msgrcv").return ?,
	__syscall.compat_ipc.msgrcv.return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgrcv.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGRCV")) next;
}

# msgsnd _____________________________________________________
# long sys_msgsnd (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             int msgflg)
#
probe syscall.msgsnd = kernel.function("sys_msgsnd").call ?
{
	name = "msgsnd"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %s", __int32($msqid), $msgp, msgsz,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgsnd.return = kernel.function("sys_msgsnd").return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
# compat_sys_msgsnd ________________________________________
#
# long compat_sys_msgsnd(int first, int second, int third, void __user *uptr)
# COMPAT_SYSCALL_DEFINE4(msgsnd, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgsnd = __syscall.compat_msgsnd ?,
      __syscall.compat_ipc.msgsnd ?
{
	name = "msgsnd"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz,
			 _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgsnd = kernel.function("compat_sys_msgsnd").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	msgp_uaddr = @choose_defined($msgp, $uptr)
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgsnd = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGSND")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)
	msgp_uaddr = $ptr
}
probe syscall.compat_sys_msgsnd.return =
	kernel.function("compat_sys_msgsnd").return ?,
	__syscall.compat_ipc.msgsnd.return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgsnd.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGSND")) next;
}

# msync ______________________________________________________
# long sys_msync(unsigned long start, size_t len, int flags)
probe syscall.msync = kernel.function("sys_msync").call ?
{
	name = "msync"
	start = $start
	length = __ulong($len)
	flags = __int32($flags)
	argstr = sprintf("%p, %u, %s", start, length, _msync_flag_str(flags))
}
probe syscall.msync.return = kernel.function("sys_msync").return ?
{
	name = "msync"
	retstr = return_str(1, $return)
}

# munlock ____________________________________________________
# long sys_munlock(unsigned long start, size_t len)
probe syscall.munlock = kernel.function("sys_munlock").call ?
{
	name = "munlock"
	addr = $start
	len = $len
	argstr = sprintf("%p, %d", addr, len)
}
probe syscall.munlock.return = kernel.function("sys_munlock").return ?
{
	name = "munlock"
	retstr = return_str(1, $return)
}

# munlockall _________________________________________________
# long sys_munlockall(void)
probe syscall.munlockall = kernel.function("sys_munlockall").call ?
{
	name = "munlockall"
	argstr = ""
}
probe syscall.munlockall.return = kernel.function("sys_munlockall").return ?
{
	name = "munlockall"
	retstr = return_str(1, $return)
}

# munmap _____________________________________________________
# long sys_munmap(unsigned long addr, size_t len)
probe syscall.munmap = kernel.function("sys_munmap").call
{
	name = "munmap"
	start = $addr
	length = __ulong($len)
	argstr = sprintf("%p, %u", start, length)
}
probe syscall.munmap.return = kernel.function("sys_munmap").return
{
	name = "munmap"
	retstr = return_str(1, $return)
}
