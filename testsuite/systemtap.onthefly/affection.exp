set test "affection"

# Goal: Ensure that the mechanism for figuring out which probes can affect the
# conditions of which other probes works properly.

# Reads output from stap line by line and returns a list of pairs denoting
# affection. E.g. "1 0 3 4" means that probe 1 affects probe 0 and probe 3
# affects probe 4.
proc parse_affection {output} {
   set ret ""
   set re "probe (\[0-9\]+) can affect condition of probe (\[0-9\]+)"
   foreach line [split $output "\n"] {
      if {[regexp "^$re$" $line dummy pidx1 pidx2]} {
         set ret "$ret $pidx1 $pidx2"
      }
   }
   return [string trimleft $ret]
}

# Runs a subtest
# @subtest: the name of the subtest
# @expected_affection: the affection expected given as a list of pairs
# @script: script to test
proc run_subtest {subtest expected_affection script} {
   global test

   verbose -log "running: stap -p2 -vvv -e $script"
   if {[catch {exec stap -p2 -vvv -e $script 2>@1} out]} {
      fail "$test - $subtest (stap -p2)"
      verbose -log "stap output: $out"
      return
   }

   set actual_affection [parse_affection $out]
   verbose -log "expected affection: $expected_affection"
   verbose -log "received affection: $actual_affection"
   if {$expected_affection != $actual_affection} {
      fail "$test - $subtest (affection)"
      return
   }

   pass "$test - $subtest"
}

### SUBTESTS ###

# No affection
run_subtest "none" "" {
   global enabled = 0 // NB: we try not just 0/1 but other integral values too
   probe timer.s(5) {
       enabled = enabled ? 0 : 100;
   }
}

# NB: the [list 1 0] means "probe 1 affects condition of probe 0"
run_subtest "simple1" [list 1 0] {
   global enabled = 0
   probe timer.s(1) if (enabled != 0) {
      next
   }
   probe timer.s(5) {
      enabled = !enabled
   }
}

run_subtest "simple2" [list 0 1] {
   global enabled = 0
   probe timer.s(5) {
      enabled = enabled ? 0 : -9999
   }
   probe timer.s(1) if (enabled & 0xFFFF) {
      next
   }
}

run_subtest "self1" [list 0 0] {
   global enabled = 0
   probe timer.s(1) if (enabled) {
      enabled = !enabled
   }
}

run_subtest "self2" [list 0 1 \
                          1 1] {
   global enabled = 0
   probe timer.s(5) {
      enabled = !enabled
   }
   probe timer.s(1) if (enabled * 1 != 0) {
      enabled = !enabled
   }
}

run_subtest "many_vars_1" [list 1 0] {
   global var1 = 0
   global var2 = 1
   global var3
   probe timer.s(1) if (var1 && (var2 || var3)) {
      next
   }
   probe timer.s(5) {
      var1 = !var1
      var2 = 0xFFFF // not just boolean range!
      var3 = var1 && var2
   }
}

run_subtest "many_vars_2" [list 0 3 \
                                1 3 \
                                2 3] {
   global var1 = 0
   global var2 = -1
   global var3
   probe timer.s(5) {
      var1 = !var1
   }
   probe timer.s(7) {
      var2 = ~var2
   }
   probe timer.s(11) {
      var3 = 1-var3
   }
   probe timer.s(1) if (var1 && (var2 || var3)) {
      next
   }
}

# NB: This is a tricky test for locking. Probe 1 needs to write-lock var1, but
# also read-lock var2 which needs to be read during the re-evaluation of probe
# 0's condition in the epilogue of probe 1. XXX: make this testcase also parse
# locking info?
run_subtest "many_vars_3" [list 1 0 \
                                2 0] {
   global var1 = 29
   global var2 = -0x123
   probe timer.s(1) if (var1 || var2) {
      next
   }
   probe timer.s(2) {
      var1--
   }
   probe timer.s(3) {
      var2--
   }
}

run_subtest "many_probes_1" [list 2 0 \
                                  2 1] {
   global var1 = 0
   probe timer.s(5) if (var1) {
      next
   }
   probe timer.s(7) if (!var1) {
      next
   }
   probe timer.s(11) {
      var1 = !var1
   }
}

run_subtest "many_probes_2" [list 0 0 \
                                  0 3 \
                                  1 0 \
                                  1 3 \
                                  2 1 \
                                  2 3] {
   global var1 = 0
   global var2 = 1
   global var3
   probe timer.s(5) if (var1 || var2) {
      var1 = !var1
   }
   probe timer.s(7) if (var3) {
      var2 = !var2
   }
   probe timer.s(11) {
      var3 = !var3
   }
   probe timer.s(1) if (var1 && (var2 || var3)) {
      next
   }
}

run_subtest "functions_1" [list 1 0] {
   global enabled = 0
   probe timer.s(1) if (enabled) {
      next
   }
   function toggler() {
      enabled = !enabled
   }
   probe timer.s(5) {
      toggler()
   }
}

run_subtest "functions_2" [list 1 0] {
   global enabled = 0
   probe timer.s(1) if (enabled) {
      next
   }
   function realtoggler() {
      enabled = !enabled
   }
   function faketoggler() {
      realtoggler()
   }
   probe timer.s(5) {
      faketoggler()
   }
}

run_subtest "functions_3" [list 0 1 \
                                1 0 \
                                1 1 \
                                2 0 \
                                2 1] {
   global var1 = 0
   global var2 = 1
   function toggler1() {
      var2 = !var2
   }
   probe timer.s(1) if (var1) {
      toggler1()
   }
   function toggler2() {
      var1 = !var1
   }
   probe timer.s(2) if (!var2 || var1) {
      toggler2()
   }
   probe timer.s(5) {
      toggler1()
      toggler2()
   }
}
